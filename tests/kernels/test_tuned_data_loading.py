# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Tests for autotuned data loading."""

import sys
# Robust Mocking for missing dependencies
import unittest
from unittest.mock import MagicMock, patch


# Helper to create a package mock
def create_package_mock(name):
    m = MagicMock()
    m.__path__ = []  # Mark as package
    m.__file__ = "mock"
    return m


# Mock vllm
sys.modules["vllm"] = create_package_mock("vllm")
sys.modules["vllm.logger"] = MagicMock()

# Mock torch
sys.modules["torch"] = create_package_mock("torch")

# Mock torchax
sys.modules["torchax"] = create_package_mock("torchax")
sys.modules["torchax.ops"] = create_package_mock("torchax.ops")
sys.modules["torchax.ops.mappings"] = MagicMock()

# Mock jax hierarchy
jax = create_package_mock("jax")
sys.modules["jax"] = jax

jax_src = create_package_mock("jax._src")
sys.modules["jax._src"] = jax_src

jax_src_lib = create_package_mock("jax._src.lib")
sys.modules["jax._src.lib"] = jax_src_lib
sys.modules["jax._src.lib.xla_client"] = MagicMock()

# Mock jax._src.numpy
jax_src_numpy = create_package_mock("jax._src.numpy")
sys.modules["jax._src.numpy"] = jax_src_numpy
sys.modules["jax._src.numpy.scalar_types"] = MagicMock()

# Mock jax.sharding
sys.modules["jax.sharding"] = create_package_mock("jax.sharding")

jax_start_backend = MagicMock()  # For utils.py if needed

# Mock jax.numpy
jax_numpy = create_package_mock("jax.numpy")
sys.modules["jax.numpy"] = jax_numpy


# Configure JAX mock to return valid dtype names strings
def mock_dtype(x):
    m = MagicMock()
    # Handle both string and object inputs
    s = str(x).lower()
    if "bfloat16" in s:
        m.name = "bfloat16"
    elif "float8_e4m3fn" in s:
        m.name = "float8_e4m3fn"
    elif "int8" in s:
        m.name = "int8"
    else:
        m.name = "float32"  # Default
    return m


jax_numpy.dtype.side_effect = mock_dtype
# Allow direct access like jnp.bfloat16
jax_numpy.bfloat16 = "bfloat16"
jax_numpy.float8_e4m3fn = "float8_e4m3fn"
jax_numpy.int8 = "int8"

sys.modules["jax.experimental"] = create_package_mock("jax.experimental")
sys.modules["jax.experimental.pallas"] = MagicMock()

# Mock RPA util to avoid deep JAX deps and ensure consistent packing values
rpa_util = MagicMock()


# get_dtype_packing logic: bfloat16 (16bit) -> 2, int8 (8bit) -> 4
def mock_get_dtype_packing(dtype):
    if "int8" in str(dtype): return 4
    if "bfloat16" in str(dtype): return 2
    return 2  # Default


rpa_util.get_dtype_packing.side_effect = mock_get_dtype_packing


# align_to logic
def mock_align_to(x, a):
    return ((x + a - 1) // a) * a


rpa_util.align_to.side_effect = mock_align_to


# next_power_of_2 logic
def mock_next_power_of_2(x):
    if x <= 1: return 1
    return 1 << (x - 1).bit_length()


rpa_util.next_power_of_2.side_effect = mock_next_power_of_2

sys.modules["tpu_inference.kernels.ragged_paged_attention.v3.util"] = rpa_util

import jax.numpy as jnp  # noqa: E402

from tpu_inference.kernels.quantized_matmul import \
    tuned_block_sizes as matmul_tuning  # noqa: E402, E501; # isort: skip
from tpu_inference.kernels.ragged_paged_attention.v3 import \
    tuned_block_sizes as rpa_tuning  # noqa: E402, E501; # isort: skip

from tpu_inference.utils import get_tpu_name_slug  # noqa: E402, E501; # isort: skip


class TestTunedDataLoading(unittest.TestCase):

    def test_rpa_slug_generation(self):
        """Test that device names are correctly converted to slugs."""
        # These should match the filenames generated by migrate_to_json.py
        self.assertEqual(get_tpu_name_slug("TPU v5 Lite"), "tpu_v5e")
        self.assertEqual(get_tpu_name_slug("TPU v5e"), "tpu_v5e")
        self.assertEqual(get_tpu_name_slug("TPU v6e"), "tpu_v6e")
        self.assertEqual(get_tpu_name_slug("TPU v7"), "tpu_v7")
        self.assertEqual(get_tpu_name_slug("TPU v4"), "tpu_v4")

    @patch(
        "tpu_inference.kernels.ragged_paged_attention.v3.tuned_block_sizes.get_device_name"
    )
    @patch(
        "tpu_inference.kernels.ragged_paged_attention.v3.tuned_block_sizes.get_tpu_name_slug"
    )
    def test_rpa_loading_v7(self, mock_slug, mock_device_name):
        """Test loading RPA tuning for TPU v7 (simulated)."""
        mock_device_name.return_value = "TPU v7"
        mock_slug.return_value = "tpu_v7"

        # We need to pick a valid key that we know exists in the migrated data.
        # Based on migrate script, we know 'q_bfloat16_kv_bfloat16' exists.

        # Test a standard key
        # head_dim=128
        bkv_p, bq = rpa_tuning.get_tuned_block_sizes(
            q_dtype=jnp.bfloat16,
            kv_dtype=jnp.bfloat16,
            actual_num_q_heads=16,
            actual_num_kv_heads=16,
            head_dim=128,
            page_size=128,  # -> 128
            max_num_tokens=2048,
            pages_per_seq=100,
            sliding_window=None)
        self.assertIsNotNone(bkv_p)
        self.assertIsNotNone(bq)
        # We expect some valid integers, e.g., 16, 32 based on defaults or tuned data
        self.assertIsInstance(bkv_p, int)
        self.assertIsInstance(bq, int)

    @patch(
        "tpu_inference.kernels.ragged_paged_attention.v3.tuned_block_sizes.get_device_name"
    )
    @patch(
        "tpu_inference.kernels.ragged_paged_attention.v3.tuned_block_sizes.get_tpu_name_slug"
    )
    def test_rpa_loading_hd64(self, mock_slug, mock_device_name):
        """Test loading RPA tuning for head_dim=64 key."""
        mock_device_name.return_value = "TPU v7"
        mock_slug.return_value = "tpu_v7"

        # head_dim=64
        # This checks if the new align_to(head_dim, 64) logic works and finds the key in the JSON
        bkv_p, bq = rpa_tuning.get_tuned_block_sizes(
            q_dtype=jnp.bfloat16,
            kv_dtype=jnp.bfloat16,
            actual_num_q_heads=16,
            actual_num_kv_heads=2,
            head_dim=64,  # Should map to 64
            page_size=256,
            max_num_tokens=2048,
            pages_per_seq=100,
            sliding_window=None)
        self.assertIsNotNone(bkv_p)
        self.assertIsNotNone(bq)

    @patch("jax.devices")
    def test_matmul_loading_v6e(self, mock_jax_devices):
        """Test loading Quantized Matmul tuning for TPU v6e."""
        # Mock jax device kind
        mock_device = MagicMock()
        mock_device.device_kind = "TPU v6e"
        mock_jax_devices.return_value = [mock_device]

        # Use a key that we saw in the file view for v6:
        # (6, 128, 128, 8192, 'int8', 'int8'): (128, 128, 4096)

        val = matmul_tuning.get_tuned_block_sizes(n_batch=128,
                                                  n_out=128,
                                                  n_in=8192,
                                                  x_q_dtype='int8',
                                                  w_q_dtype='int8')

        self.assertEqual(val.batch_block_size, 128)
        self.assertEqual(val.out_block_size, 128)
        self.assertEqual(val.in_block_size, 4096)

    @patch("jax.devices")
    def test_matmul_loading_fallback(self, mock_jax_devices):
        """Test fallback when key is missing."""
        mock_device = MagicMock()
        mock_device.device_kind = "TPU v6e"
        mock_jax_devices.return_value = [mock_device]

        # Missing key
        val = matmul_tuning.get_tuned_block_sizes(n_batch=9999,
                                                  n_out=9999,
                                                  n_in=9999,
                                                  x_q_dtype='int8',
                                                  w_q_dtype='int8')

        # Expect defaults
        self.assertEqual(val.batch_block_size, 128)


if __name__ == '__main__':
    unittest.main()
